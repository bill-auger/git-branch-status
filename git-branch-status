#!/usr/bin/env bash

#  git-branch-status - print pretty git branch sync status reports
#
#  Copyright 2011      Jehiah Czebotar     <https://github.com/jehiah>
#  Copyright 2013      Fredrik Strandin    <https://github.com/kd35a>
#  Copyright 2014      Kristijan Novoselić <https://github.com/knovoselic>
#  Copyright 2014-2020 bill-auger          <https://github.com/bill-auger>
#
#  git-branch-status is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License version 3
#  as published by the Free Software Foundation.
#
#  git-branch-status is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License version 3
#  along with git-branch-status.  If not, see <http://www.gnu.org/licenses/>.

#  credits:
#    * original `git rev-list` grepping - by Jehiah Czebotar
#    * "s'all good!" message            - by Fredrik Strandin
#    * ANSI colors                      - by Kristijan Novoselić
#    * various features and maintenance - by bill-auger

#  please direct bug reports, feature requests, or PRs to one of the upstream repos:
#    * https://github.com/bill-auger/git-branch-status/issues/
#    * https://notabug.org/bill-auger/git-branch-status/issues/
#    * https://pagure.io/git-branch-status/issues/


read -r -d '' USAGE <<-'USAGE_MSG'
USAGE:

  git-branch-status
  git-branch-status [ base-branch-name compare-branch-name ]
  git-branch-status [ -a | --all ]
  git-branch-status [ -b | --branch ] [ filter-branch-name ]
  git-branch-status [ -d | --dates ]
  git-branch-status [ -h | --help ]
  git-branch-status [ -l | --local ]
  git-branch-status [ -r | --remotes ]
  git-branch-status [ -v | --verbose ]


EXAMPLES:

  # show only branches for which upstream differs from local
  $ git-branch-status
    | collab-branch  | (behind 1) | (ahead 2) | origin/collab-branch  |
    | feature-branch | (even)     | (ahead 2) | origin/feature-branch |
    | master         | (behind 1) | (even)    | origin/master         |

  # compare two arbitrary branches - local or remote
  $ git-branch-status a-branch another-branch
    | a-branch            | (even)     | (even) | another-branch            |
  $ git-branch-status a-branch a-remote/any-branch
    | a-branch            | (even)     | (even) | a-remote/any-branch       |
  $ git-branch-status a-remote/any-branch a-branch
    | a-remote/any-branch | (behind 1) | (even) | a-branch                  |
  $ git-branch-status a-remote/any-branch other-remote/other-branch
    | a-remote/any-branch | (behind 1) | (even) | other-remote/other-branch |

  # show all branches - local and remote, regardless of state or relationship
  $ git-branch-status -a
  $ git-branch-status --all
   *| master         | (even)     | (ahead 1) | origin/master             |
    | tracked-branch | (even)     | (even)    | origin/tracked-branch     |
    | (no local)     | n/a        | n/a       | origin/untracked-branch   |
    | local-branch   | n/a        | n/a       | (no upstream)             |
    | master         | (behind 1) | (ahead 1) | a-remote/master           |
    | (no local)     | n/a        | n/a       | a-remote/untracked-branch |

  # show the current branch
  $ git-branch-status -b
  $ git-branch-status --branch
   *| current-branch | (even) | (ahead 2) | origin/current-branch |

  # show a specific branch
  $ git-branch-status          specific-branch
  $ git-branch-status -b       specific-branch
  $ git-branch-status --branch specific-branch
    | specific-branch | (even) | (ahead 2) | origin/specific-branch |

  # compare a specific local branch against all other local branches
  $ git-branch-status -c        master
  $ git-branch-status --cleanup master
   *| master             | (behind 2) | (even)    | master |
    | merged-into-master | (even)     | (even)    | master |
    | wip                | (even)     | (ahead 1) | master |
    branch: merged-into-master is identical to: master
    Delete merged-into-master? [y/N]

  # show the timestamp of each out-of-sync local ref
  $ git-branch-status -d
  $ git-branch-status --dates
    | 1999-12-30 master   | (even)     | (even) | 1999-12-30 origin/master  |
    | 1999-12-31 devel    | (behind 2) | (even) | 2000-01-01 origin/devel   |

  # show the timestamp of arbitrary branch refs
  $ git-branch-status -d      a-branch another-branch
  $ git-branch-status --dates a-branch another-branch
    | 1999-12-31 a-branch | (even)     | (even) | 2000-01-01 another-branch |

  # print this usage message
  $ git-branch-status -h
  $ git-branch-status --help
      "prints this usage message"

  # show all local branches - including those synchronized or non-tracking
  $ git-branch-status -l
  $ git-branch-status --local
   *| master         | (even)     | (ahead 1) | origin/master         |
    | tracked-branch | (even)     | (even)    | origin/tracked-branch |
    | local-branch   | n/a        | n/a       | (no upstream)         |

  # show all remote branches - including those not checked-out
  $ git-branch-status -r
  $ git-branch-status --remotes
    | master     | (behind 1) | (even) | a-remote/master           |
    | (no local) | n/a        | n/a    | a-remote/untracked-branch |

  # show all branches with timestamps (like -a -d)
  $ git-branch-status -v
  $ git-branch-status --verbose
    | 1999-12-31 master    | (behind 1) | (even) | 2000-01-01 origin/master  |
    | 1999-12-31 tracked   | (even)     | (even) | 2000-01-01 origin/tracked |
   *| 1999-12-31 local-wip | n/a        | n/a    | (no upstream)             |
USAGE_MSG


## user-defined configuration (see ./gbs-config.sh.inc.example) ##

readonly THIS_DIR="$(dirname "$(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || echo $0)")"
readonly DEF_CFG_FILE="${THIS_DIR}"/gbs-config.sh.inc
readonly DEF_FETCH_PERIOD='-1'
readonly DEF_LAST_FETCH_FILE=~/.GBS_LAST_FETCH
readonly DEF_USE_ANSI_COLOR='1'
readonly DEF_SHOW_AUTHOR_DATES='0'
readonly CFG_FILE=$(          ( [[ "$GBS_CFG_FILE" && -f "$GBS_CFG_FILE" ]] && echo -n "$GBS_CFG_FILE"          ) || \
                              ( [[ "$DEF_CFG_FILE" && -f "$DEF_CFG_FILE" ]] && echo -n "$DEF_CFG_FILE"          )    )
source "$CFG_FILE" 2> /dev/null
readonly FETCH_PERIOD=$(      ( [[ "$GBS_FETCH_PERIOD" =~ ^-?[0-9]+$     ]] && echo -n "$GBS_FETCH_PERIOD"      ) || \
                              ( [[ "$CFG_FETCH_PERIOD" =~ ^-?[0-9]+$     ]] && echo -n "$CFG_FETCH_PERIOD"      ) || \
                                                                               echo -n "$DEF_FETCH_PERIOD"           )
readonly LAST_FETCH_FILE=$(   ( touch "$GBS_LAST_FETCH_FILE" 2> /dev/null   && echo -n "$GBS_LAST_FETCH_FILE"   ) || \
                              ( touch "$CFG_LAST_FETCH_FILE" 2> /dev/null   && echo -n "$CFG_LAST_FETCH_FILE"   ) || \
                                                                               echo -n "$DEF_LAST_FETCH_FILE"        )
readonly USE_ANSI_COLOR=$(    ( [[ "$GBS_USE_ANSI_COLOR" =~ ^[01]$       ]] && echo -n "$GBS_USE_ANSI_COLOR"    ) || \
                              ( [[ "$CFG_USE_ANSI_COLOR" =~ ^[01]$       ]] && echo -n "$CFG_USE_ANSI_COLOR"    ) || \
                                                                               echo -n "$DEF_USE_ANSI_COLOR"         )
readonly SHOW_AUTHOR_DATES=$( ( [[ "$GBS_SHOW_AUTHOR_DATES" =~ ^[01]$    ]] && echo -n "$GBS_SHOW_AUTHOR_DATES" ) || \
                              ( [[ "$CFG_SHOW_AUTHOR_DATES" =~ ^[01]$    ]] && echo -n "$CFG_SHOW_AUTHOR_DATES" ) || \
                                                                               echo -n "$DEF_SHOW_AUTHOR_DATES"      )


## constants ##

readonly INNER_PADDING_W=13 # '| ' + ' | ' + ' | ' + ' | ' + ' |'
readonly MARGIN_PAD_W=2
readonly MARGINS_PAD_W=$(( $MARGIN_PAD_W * 2 ))
readonly ALL_PADDING_W=$(( $INNER_PADDING_W + $MARGINS_PAD_W ))
readonly MAX_DIVERGENCE=999
readonly MAX_DIVERGENCE_W=$(( 9 + ${#MAX_DIVERGENCE} )) # e.g. "(behind 999)"
readonly MIN_TTY_W=60 # ASSERT: (0 < (ALL_PADDING_W + (MAX_DIVERGENCE_W * 2)) <= MIN_TTY_W)
readonly MARGIN_PAD=$(printf "%$(( $MARGIN_PAD_W ))s")
readonly CWHITE=$(  (( $USE_ANSI_COLOR )) && echo '\033[0;37m' )
readonly CRED=$(    (( $USE_ANSI_COLOR )) && echo '\033[0;31m' )
readonly CGREEN=$(  (( $USE_ANSI_COLOR )) && echo '\033[0;32m' )
readonly CYELLOW=$( (( $USE_ANSI_COLOR )) && echo '\033[1;33m' )
readonly CBLUE=$(   (( $USE_ANSI_COLOR )) && echo '\033[1;34m' )
readonly CEND=$(    (( $USE_ANSI_COLOR )) && echo '\033[0m'    )
readonly CDEFAULT=$CWHITE
readonly CTRACKING=$CBLUE
readonly CAHEAD=$CYELLOW
readonly CBEHIND=$CRED
readonly CEVEN=$CGREEN
readonly CNOUPSTREAM=$CRED
readonly CNOLOCAL=$CRED
readonly CNODIFF=$CGREEN
readonly HRULE_CHAR='-'
readonly JOIN_CHAR='~'
readonly JOIN_REGEX="s/$JOIN_CHAR/ /g"
readonly STAR='*'
readonly DELIM='|'
readonly TTY_W_MSG="TTY must be wider than $MIN_TTY_W chars"
readonly NOT_REPO_MSG="Not a git repo"
readonly BARE_REPO_MSG="Bare repo"
readonly NO_COMMITS_MSG="No commits"
readonly INVALID_BRANCH_MSG="No such branch:"
readonly INVALID_LOCAL_BRANCH_MSG="No such local branch:"
readonly ARG_REQUIRED_MSG="This option requires an argument"
readonly NO_UPSTREAM="(no${JOIN_CHAR}upstream)"
readonly NO_LOCAL="(no${JOIN_CHAR}local)"
readonly NO_RESULTS_MSG="Nothing to compare"
readonly NO_REFS_MSG="(No data)"
readonly LOCALS_SYNCED_MSG="All tracking branches are synchronized with their upstreams"
readonly BRANCH_SYNCED_MSG="This tracking branch is synchronized with it's upstream"
readonly UNTRACKED_SYNCHED_MSG="These branches are synchronized with no tracking relationship"
readonly REMOTES_SYNCED_MSG="All local branches with corresponding names on this remote are synchronized with that remote"
readonly EXIT_SUCCESS=0
readonly EXIT_FAILURE=1
# readonly IS_CLEANUP_MODE # Init()
# readonly SHOW_DATES      # Init()
# readonly SHOW_ALL_SYNCED # Init()
# readonly SHOW_ALL_LOCAL  # Init()
# readonly SHOW_ALL_REMOTE # Init()
# readonly FILTER_BRANCH   # Init()
# readonly COMPARE_BRANCH  # Init()


## variables ##

WereAnyDivergences=0
WereAnyCompared=0
LocalW=0
BehindW=0
AheadW=0
RemoteW=0
declare -a BranchLeftTexts=()
declare -a BehindTexts=()
declare -a TrackingTexts=()
declare -a AheadTexts=()
declare -a BranchRightTexts=()
declare -a BranchLeftColors=()
declare -a BehindColors=()
declare -a TrackingColors=()
declare -a AheadColors=()
declare -a BranchRightColors=()


## helpers ##

AssertIsValidRepo()
{
  [[ "$(git rev-parse --is-inside-work-tree 2> /dev/null)" == 'true' ]] || \
  ! (( $(AssertIsNotBareRepo) ))                                        && echo 1 || echo 0
}

AssertHasCommits()
{
  [[ "$(git cat-file -t HEAD 2> /dev/null)" ]] && echo 1 || echo 0
}

AssertIsNotBareRepo()
{
  [[ "$(git rev-parse --is-bare-repository 2> /dev/null)" != 'true' ]] && echo 1 || echo 0
}

GetRefs() # (refs_dir)
{
  local refs_dir=$1
  local fmt='%(refname:short) %(upstream:short)'
  local sort_key=$( (( $SHOW_AUTHOR_DATES )) && echo 'authordate' || echo 'committerdate' )
  local sort=$(     (( $SHOW_DATES        )) && echo "--sort=$sort_key"                   )

  git for-each-ref --format="$fmt" $sort $refs_dir 2> /dev/null
}

GetLocalRefs()
{
  GetRefs refs/heads
}

GetRemoteRefs() # (remote_repo_name)
{
  local remote_repo=$1

  GetRefs refs/remotes/$remote_repo
}

GetStatus() # (base_commit compare_commit)
{
  local base_commit=$1
  local compare_commit=$2

  git rev-list --left-right ${base_commit}...${compare_commit} -- 2>/dev/null
}

GetCurrentBranch()
{
  git rev-parse --abbrev-ref HEAD
}

GetUpstreamBranch() # (local_branch)
{
  local local_branch=$1

  git rev-parse --abbrev-ref $local_branch@{upstream} 2> /dev/null
}

IsCurrentBranch() # (branch_name)
{
  local branch=$1
  local this_branch=$(   AppendMetadata $branch            )
  local current_branch=$(AppendMetadata $(GetCurrentBranch))

  [[ "$this_branch" == "$current_branch" ]] && echo 1 || echo 0
}

IsLocalBranch() # (branch_name)
{
  local branch=$1
  local is_local_branch=$(git branch -a | grep -E "^.* $branch$")

  [[ "$is_local_branch" ]] && echo 1 || echo 0
}

IsTrackedBranch() # (base_branch_name compare_branch_name)
{
  local base_branch=$1
  local compare_branch=$2
  local upstream_branch=$(GetUpstreamBranch $base_branch)

  [[ "$compare_branch" == "$upstream_branch" ]] && echo 1 || echo 0
}

DoesBranchExist() # (branch_name)
{
  local branch=$1
  local is_known_branch=$(git branch -a | grep -E "^.* (remotes/)?$branch$")

  [[ "$is_known_branch" ]] && echo 1 || echo 0
}

IsNoDiff() # (base_branch compare_branch)
{
  git diff --exit-code $1 $2 &> /dev/null ; echo $(( ! $? )) ;
}

GitMeta() # (ref fmt)
{
  git log -n 1 --format=format:"$2" $1 2> /dev/null | head -n 1 | tr '\t ' "${JOIN_CHAR}"
}

AppendMetadata() # (ref)
{
  local ref="$1"
  local date_fmt=$( (( ${SHOW_AUTHOR_DATES} )) && echo '%as' || echo '%cs' )
  local log_fmt='%B'
  local date=$(GitMeta $ref "$date_fmt")
  local log="$(GitMeta $ref "$log_fmt" )"

  (( SHOW_DATES )) && echo -n "${date}${JOIN_CHAR}"
  (( SHOW_LOGS  )) && echo "${ref}:${JOIN_CHAR}${log}" || echo "${ref}"
}

CurrentTtyW()
{
  local tty_dims=$(stty -F /dev/tty size 2> /dev/null || stty -f /dev/tty size 2> /dev/null)
  local tty_w=$(echo $tty_dims | cut -d ' ' -f 2)

  (( $tty_w )) && echo "$tty_w" || echo "$MIN_TTY_W"
}

PrintHRule() # (rule_width)
{
  local rule_w=$1
  local h_rule="$(dd if=/dev/zero bs=$rule_w count=1 2> /dev/null | tr '\0' $HRULE_CHAR)"

  echo "$MARGIN_PAD$h_rule"
}

Exit() # (exit_msg exit_status)
{
  local exit_msg=$1
  local exit_status=$2

  case "$exit_status" in
       $EXIT_SUCCESS      ) echo "$exit_msg"        ; exit $EXIT_SUCCESS ;;
       $EXIT_FAILURE | '' ) echo "fatal: $exit_msg" ; exit $EXIT_FAILURE ;;
  esac
}


## testing ##

TEST_CONFIG()
{
  echo "THIS_DIR=$THIS_DIR"
  echo "GBS_CFG_FILE=$( [[ -f "$GBS_CFG_FILE" ]] && echo "(exists): " )$GBS_CFG_FILE"
  echo "DEF_CFG_FILE=$( [[ -f "$DEF_CFG_FILE" ]] && echo "(exists): " )$DEF_CFG_FILE"
  echo "GBS_FETCH_PERIOD=$GBS_FETCH_PERIOD"
  echo "CFG_FETCH_PERIOD=$CFG_FETCH_PERIOD"
  echo "FETCH_PERIOD=$FETCH_PERIOD"
  echo "GBS_LAST_FETCH_FILE=$GBS_LAST_FETCH_FILE"
  echo "CFG_LAST_FETCH_FILE=$CFG_LAST_FETCH_FILE"
  echo "LAST_FETCH_FILE=$LAST_FETCH_FILE"
  echo "GBS_USE_ANSI_COLOR=$GBS_USE_ANSI_COLOR"
  echo "CFG_USE_ANSI_COLOR=$CFG_USE_ANSI_COLOR"
  echo "USE_ANSI_COLOR=$USE_ANSI_COLOR"
}

TEST_ARGS()
{
  echo "is_all_mode=$is_all_mode"
  echo "is_branch_mode=$is_branch_mode"
  echo "is_cleanup_mode=$is_cleanup_mode"
  echo "is_dates_mode=$is_dates_mode"
  echo "is_local_mode=$is_local_mode"
  echo "is_remotes_mode=$is_remotes_mode"
  echo "is_verbose_mode=$is_verbose_mode"
  echo "is_default_mode=$is_default_mode"
}


## business ##

Init() # (cli_args)
{
  local is_all_mode=0
  local is_branch_mode=0
  local is_cleanup_mode=0
  local is_dates_mode=0
  local is_local_mode=0
  local is_logs_mode=0
  local is_remotes_mode=0
  local is_verbose_mode=0
  local is_default_mode=0
  local show_dates=0
  local show_all=0
  local show_all_synced=0
  local show_all_local=0
  local show_all_remote=0
  local branch_a=''
  local branch_b=''

  # parse CLI switches
  case "$1" in
       '-a'|'--all'     ) is_all_mode=1               ;;
       '-b'|'--branch'  ) is_branch_mode=1            ;;
       '-c'|'--cleanup' ) is_cleanup_mode=1           ;;
       '-d'|'--dates'   ) is_dates_mode=1             ;;
       '-h'|'--help'    ) Exit "$USAGE" $EXIT_SUCCESS ;;
       '-l'|'--local'   ) is_local_mode=1             ;;
       '-L'|'--logs'    ) is_logs_mode=1              ;;
       '-r'|'--remotes' ) is_remotes_mode=1           ;;
       '-v'|'--verbose' ) is_verbose_mode=1           ;;
       *                ) is_default_mode=1           ;;
  esac

  (( $GBS_TEST_CFG )) && TEST_CONFIG && TEST_ARGS && exit

  # prepare state
  (( $is_all_mode     )) && show_all=1
  (( $is_branch_mode  )) && branch_a=$( [[ "$2" ]] && echo $2 || echo $(GetCurrentBranch) )
  (( $is_cleanup_mode )) && branch_a="$2"     show_all_synced=1 show_dates=1
  (( $is_dates_mode   )) && branch_a=$2       branch_b=$3       show_dates=1
  (( $is_local_mode   )) && show_all_local=1  show_all_synced=1
  (( $is_logs_mode    )) && branch_a=$2       branch_b=$3       show_logs=1
  (( $is_remotes_mode )) && show_all_remote=1 show_all_synced=1
  (( $is_verbose_mode )) && show_all=1        show_dates=1      show_logs=1
  (( $is_default_mode )) && branch_a=$1       branch_b=$2
  [[ "$branch_a"      ]] && show_all_local=1 # force "no upstream" message for non-tracking branches

  # sanity checks
  (( $(CurrentTtyW) >= $MIN_TTY_W ))                         || Exit "$TTY_W_MSG"
  (( $(AssertIsValidRepo        ) ))                         || Exit "$NOT_REPO_ERR"
  (( $(AssertIsNotBareRepo      ) ))                         || Exit "$BARE_REPO_MSG"
  (( $(AssertHasCommits         ) ))                         || Exit "$NO_COMMITS_MSG"
  (( $(DoesBranchExist $branch_a) )) || [[ -z "$branch_a" ]] || Exit "$INVALID_BRANCH_MSG '$branch_a'"
  (( $(DoesBranchExist $branch_b) )) || [[ -z "$branch_b" ]] || Exit "$INVALID_BRANCH_MSG '$branch_b'"
  (( ! $is_cleanup_mode           )) || [[ -n "$branch_a" ]] || Exit "$ARG_REQUIRED_MSG"

  readonly IS_CLEANUP_MODE=$is_cleanup_mode
  readonly SHOW_DATES=$show_dates
  readonly SHOW_LOGS=$show_logs
  readonly SHOW_ALL_SYNCED=$(( $show_all + $show_all_synced )) # show branches that are synchronized with their counterparts
  readonly SHOW_ALL_LOCAL=$((  $show_all + $show_all_local  )) # show local branches that are not tracking any upstream
  readonly SHOW_ALL_REMOTE=$(( $show_all + $show_all_remote )) # show all remote branches
  readonly FILTER_BRANCH=$branch_a
  readonly COMPARE_BRANCH=$branch_b
}

FetchRemotes()
{
  if   (( ${FETCH_PERIOD} >= 0 )) && (( ! ${IS_CLEANUP_MODE} ))
  then local now_ts=$(date +%s)
       local last_fetch_ts=$(( $(cat ${LAST_FETCH_FILE} 2> /dev/null) + 0 ))

       if   (( ${now_ts} - ${last_fetch_ts} >= ${FETCH_PERIOD} * 60 ))
       then git fetch --all
            echo -n ${now_ts} > ${LAST_FETCH_FILE}
       fi
  fi
}

GenerateReports()
{
  if   (( ${IS_CLEANUP_MODE} ))
  then CleanupReport
  elif [[ "$COMPARE_BRANCH" ]]
  then ArbitraryReport $(IsTrackedBranch $FILTER_BRANCH $COMPARE_BRANCH)
  else (( ! $SHOW_ALL_REMOTE || $SHOW_ALL_LOCAL )) && LocalReport
       (( $SHOW_ALL_REMOTE                      )) && RemoteReport
  fi
}

CleanupReport()
{
  local n_results
  local result_n
  local branch_l_text
  local behind_text
  local ahead_text
  local branch_r_text
  local compare_branch
  local is_behind
  local is_ahead
  local compare_branches=()

  # compare all local branches against $FILTER_BRANCH
  while read local upstream ; do GenerateReport ${local} ${FILTER_BRANCH} ; done < <(GetLocalRefs) ;

  n_results=${#BranchLeftTexts[@]}

  for (( result_n = 0 ; result_n < n_results ; ++result_n ))
  do  branch_l_text=$(echo ${BranchLeftTexts[  $result_n ]}         | sed "$JOIN_REGEX")
      behind_text=$(  echo ${BehindTexts[      $result_n ]:$trim_w} | sed "$JOIN_REGEX")
      ahead_text=$(   echo ${AheadTexts[       $result_n ]:$trim_w} | sed "$JOIN_REGEX")
      branch_r_text=$(echo ${BranchRightTexts[ $result_n ]}         | sed "$JOIN_REGEX")
      compare_branch=$( sed -E "s|[0-9-]* +(.*)|\1|" <<<${branch_l_text}  )
      is_behind=$( [[ "${behind_text}" != "(even)" ]] && echo 1 || echo 0 )
      is_ahead=$(  [[ "${ahead_text}"  != "(even)" ]] && echo 1 || echo 0 )

      ! (( $is_behind + $is_ahead )) && compare_branches+=( $compare_branch )
  done

  n_results=${#compare_branches[@]}

  PrintReport "locals <-> ${FILTER_BRANCH}" ""
  for (( result_n = 0 ; result_n < n_results ; ++result_n ))
  do  compare_branch=${compare_branches[$result_n]}
      echo -e "\tbranch: $compare_branch is identical to: $base_branch\n\tDelete $compare_branch? [y/N]"
      read -p " " -n 1 -r ; echo ; [[ $REPLY =~ ^[Yy]$ ]] && git branch -D $compare_branch > /dev/null
  done
}

ArbitraryReport() # (is_tracked_branch)
{
  local is_tracked_branch=$1
  local synchronized_msg=$( (( $is_tracked_branch )) && echo "$BRANCH_SYNCED_MSG"     || \
                                                        echo "$UNTRACKED_SYNCHED_MSG"    )

  # compare sync status of arbitrary branches per cli args
  GenerateReport $FILTER_BRANCH $COMPARE_BRANCH
  PrintReport "$FILTER_BRANCH <-> $COMPARE_BRANCH" "$synchronized_msg"
}

LocalReport()
{
  local synchronized_msg=$( [[ "$FILTER_BRANCH" ]] && echo "$BRANCH_SYNCED_MSG" || \
                                                      echo "$LOCALS_SYNCED_MSG"    )

  # compare sync status of local branches to their upstreams
  while read local upstream ; do GenerateReport $local $upstream ; done < <(GetLocalRefs) ;
  PrintReport "local <-> upstream" "$synchronized_msg"
}

RemoteReport()
{
  local synchronized_msg="$REMOTES_SYNCED_MSG"
  local remote_repo

  # compare sync status of remote branches to local branches with the same names
  for remote_repo in $(git remote)
  do  while read remote_branch
      do    local local_branch=${remote_branch#$remote_repo/}

            GenerateReport $local_branch $remote_branch
      done < <(GetRemoteRefs $remote_repo)

      PrintReport "local <-> $remote_repo" "$synchronized_msg"
  done
}

GenerateReport() # (base_branch compare_branch)
{
  local base_branch=$1
  local compare_branch=$2
  local does_base_branch_exist=$(   DoesBranchExist $base_branch                )
  local does_compare_branch_exist=$(DoesBranchExist $compare_branch             )
  local is_tracking=$(              IsTrackedBranch $base_branch $compare_branch)
  local is_nodiff
  local branch_l_text  ; local branch_l_color ;
  local behind_text    ; local behind_color   ;
  local tracking_text  ; local tracking_color ;
  local ahead_text     ; local ahead_color    ;
  local branch_r_color ; local branch_r_text  ;

  # filter out heads
  [[ "$base_branch" != 'HEAD' ]] || return

  if   (( $IS_CLEANUP_MODE ))
  then # avoid comparing compare_branch against itself in cleanup mode
       [[ "$base_branch" != "$compare_branch"                       ]] || return
  else # filter branches per CLI arg
       [[ -z "$FILTER_BRANCH" || "$base_branch" == "$FILTER_BRANCH" ]] || return
  fi

  if   (( ! $does_base_branch_exist )) && (( ! $does_compare_branch_exist )) ; then return ;
  elif ((   $does_base_branch_exist )) && ((   $does_compare_branch_exist ))
  then # parse local<->remote or arbitrary branches sync status
       local status=$(GetStatus $base_branch $compare_branch) ; local was_error=$?
       local n_behind=$(echo $status | tr " " "\n" | grep -c '^>')
       local n_ahead=$( echo $status | tr " " "\n" | grep -c '^<')
       local n_divergences=$(( $n_behind + $n_ahead ))
       local join_char=${JOIN_CHAR}
       (( $n_behind > $MAX_DIVERGENCE          )) && n_behind=$MAX_DIVERGENCE join_char='>'
       (( $n_ahead  > $MAX_DIVERGENCE          )) && n_ahead=$MAX_DIVERGENCE  join_char='>'
       (( $WereAnyDivergences + $n_divergences )) && WereAnyDivergences=1
       (( ! $was_error                         )) && WereAnyCompared=1 || return

       # filter branches by status
       (( $SHOW_ALL_SYNCED )) || (( $n_divergences > 0 )) || return

       # set data for branches with remote counterparts or arbitrary branches
       is_nodiff=$(git diff --exit-code $base_branch $compare_branch &> /dev/null ; echo $((!$?)) ; )
       behind_text=$(      (( $n_behind   )) && echo "(behind${join_char}${n_behind})" || echo "(even)" )
       ahead_text=$(       (( $n_ahead    )) && echo "(ahead${join_char}${n_ahead})"   || echo "(even)" )
       branch_l_color=$( ( (( is_nodiff   )) && echo $CNODIFF   ) || \
                         ( (( is_tracking )) && echo $CTRACKING ) || echo $CDEFAULT )
       behind_color=$(     (( $n_behind   )) && echo $CBEHIND     || echo $CEVEN    )
       ahead_color=$(      (( $n_ahead    )) && echo $CAHEAD      || echo $CEVEN    )
       branch_r_color=$branch_l_color
  elif ((   $does_base_branch_exist )) && (( $SHOW_ALL_LOCAL ))
  then # dummy data for local branches with no upstream counterpart
       branch_l_color=$CDEFAULT
       behind_color=$CDEFAULT      ; behind_text="n/a"             ;
       ahead_color=$CDEFAULT       ; ahead_text="n/a"              ;
       branch_r_color=$CNOUPSTREAM ; compare_branch="$NO_UPSTREAM" ;
  elif (( ! $does_base_branch_exist )) && (( $SHOW_ALL_REMOTE ))
  then # dummy data for remote branches with no local counterpart
       branch_l_color=$CNOLOCAL    ; base_branch="$NO_LOCAL"       ;
       behind_color=$CDEFAULT      ; behind_text="n/a"             ;
       ahead_color=$CDEFAULT       ; ahead_text="n/a"              ;
       branch_r_color=$CDEFAULT
  else return
  fi
  branch_l_text="$(AppendMetadata $base_branch   )"
  branch_r_text="$(AppendMetadata $compare_branch)"
  tracking_text=$(  (( is_tracking )) && echo "-$DELIM-" || echo $JOIN_CHAR$DELIM$JOIN_CHAR )
  tracking_color=$( (( is_tracking )) && echo $CTRACKING || echo $CDEFAULT                  )

  # populate lists
  BranchLeftTexts=(   ${BranchLeftTexts[@]}   "$branch_l_text"  )
  BehindTexts=(       ${BehindTexts[@]}       "$behind_text"    )
  TrackingTexts=(     ${TrackingTexts[@]}     "$tracking_text"  )
  AheadTexts=(        ${AheadTexts[@]}        "$ahead_text"     )
  BranchRightTexts=(  ${BranchRightTexts[@]}  "$branch_r_text"  )
  BranchLeftColors=(  ${BranchLeftColors[@]}  "$branch_l_color" )
  BehindColors=(      ${BehindColors[@]}      "$behind_color"   )
  TrackingColors=(    ${TrackingColors[@]}    "$tracking_color" )
  AheadColors=(       ${AheadColors[@]}       "$ahead_color"    )
  BranchRightColors=( ${BranchRightColors[@]} "$branch_r_color" )

  # determine uniform column widths
  if [[ ${#branch_l_text} -gt $LocalW  ]] ; then LocalW=${#branch_l_text}  ; fi ;
  if [[ ${#behind_text}   -gt $BehindW ]] ; then BehindW=${#behind_text}   ; fi ;
  if [[ ${#ahead_text}    -gt $AheadW  ]] ; then AheadW=${#ahead_text}     ; fi ;
  if [[ ${#branch_r_text} -gt $RemoteW ]] ; then RemoteW=${#branch_r_text} ; fi ;
}

PrintReport() # (table_header_line synchronized_msg)
{
  local table_header_line=$1
  local synchronized_msg=$2
  local available_w=$(( $(CurrentTtyW) - $AheadW - $BehindW - $ALL_PADDING_W ))
  local n_results=${#BranchLeftTexts[@]}
  local are_all_in_sync
  local result_n
  (( $WereAnyCompared )) && !(( $WereAnyDivergences )) && are_all_in_sync=1 || are_all_in_sync=0

  # truncate column widths to fit
  while (( $LocalW + $RemoteW > $available_w ))
  do    (( $LocalW >= $RemoteW )) && LocalW=$((  $LocalW  - 1 ))
        (( $LocalW <= $RemoteW )) && RemoteW=$(( $RemoteW - 1 ))
  done

  # print comparison header
  if   (( $are_all_in_sync ))
  then printf "\n$CGREEN$MARGIN_PAD$table_header_line$CEND\n"
  elif (( $n_results > 0 ))
  then printf "\n$MARGIN_PAD$table_header_line\n"
  else printf "\n$CRED$MARGIN_PAD$table_header_line$CEND$MARGIN_PAD"
  fi

  # pretty print divergence results
  if   (( $n_results > 0 ))
  then local rule_w=$(( $LocalW + $BehindW + $AheadW + $RemoteW + $INNER_PADDING_W ))

       PrintHRule $rule_w
       for (( result_n = 0 ; result_n < n_results ; ++result_n ))
       do  PrintReportLine
       done
       PrintHRule $rule_w
  else ([ -z "$(GetRemoteRefs $remote_repo)" ] && printf "$CRED$NO_REFS_MSG$CEND\n") || \
       (!(( $are_all_in_sync ))                && echo "$NO_RESULTS_MSG"           )
  fi

  # print "synchronized" message if all compared upstreams had no divergence
  if   (( $are_all_in_sync ))
  then local l_border="$DELIM " ; local r_border=" $DELIM" ;
       local borders_pad_w=$(( ${#l_border} + ${#r_border} ))
       local wrap_w=$(( $(CurrentTtyW) - $MARGINS_PAD_W - $borders_pad_w ))
       local line
       local rule_w=0

       # wrap message and determine box width
       synchronized_msg=$(echo "$synchronized_msg" | fold -s -w $wrap_w | tr ' ' "$JOIN_CHAR")
       for line in $synchronized_msg
       do  line=${line/%$JOIN_CHAR/}
           [[ ${#line} -gt $rule_w ]] && rule_w=${#line}
       done
       rule_w=$(( $rule_w + $MARGINS_PAD_W ))

       # display message
       PrintHRule $rule_w
       for line in $synchronized_msg
       do  line=${line/%$JOIN_CHAR/}
           local pad_w=$(( $rule_w - ${#line} - $MARGINS_PAD_W ))
           local line_fmt="$MARGIN_PAD$l_border$CEVEN$line$CEND%$(( $pad_w ))s$r_border"
           printf "$line_fmt\n" | sed "$JOIN_REGEX"
       done
       PrintHRule $rule_w
  fi

  Reset
}

PrintReportLine()
{
  # select data
  local branch_l_text=$(echo ${BranchLeftTexts[ $result_n]}         | sed "$JOIN_REGEX")
  local behind_text=$(  echo ${BehindTexts[     $result_n]:$trim_w} | sed "$JOIN_REGEX")
  local tracking_text=$(echo ${TrackingTexts[   $result_n]}         | sed "$JOIN_REGEX")
  local ahead_text=$(   echo ${AheadTexts[      $result_n]:$trim_w} | sed "$JOIN_REGEX")
  local branch_r_text=$(echo ${BranchRightTexts[$result_n]}         | sed "$JOIN_REGEX")
  local star delim end_msg
  branch_l_text="${branch_l_text:0:$LocalW}"
  branch_r_text="${branch_r_text:0:$RemoteW}"
  local branch_l_color="${BranchLeftColors[  $result_n ]}"
  local behind_color="${BehindColors[        $result_n ]}"
  local tracking_color="${TrackingColors[    $result_n ]}"
  local ahead_color="${AheadColors[          $result_n ]}"
  local branch_r_color="${BranchRightColors[ $result_n ]}"

  # calculate column offsets
  local branch_l_offset=1
  local behind_offset=$((   $LocalW  - ${#branch_l_text} ))
  local ahead_offset=$((    $BehindW - ${#behind_text}   ))
  local branch_r_offset=$(( $AheadW  - ${#ahead_text}    ))
  local end_offset=$((      $RemoteW - ${#branch_r_text} ))

  # build output messages and display
  (( $(IsCurrentBranch $branch_l_text) )) && star=$STAR || star=" "
  delim="$tracking_color$tracking_text$CEND"
  branch_l_text="%$(( $branch_l_offset ))s$star$DELIM $branch_l_color$branch_l_text$CEND"
  behind_text="%$((   $behind_offset   ))s $DELIM $behind_color$behind_text$CEND"
  ahead_text="%$((    $ahead_offset    ))s$delim$ahead_color$ahead_text$CEND"
  branch_r_text="%$(( $branch_r_offset ))s $DELIM $branch_l_color$branch_r_text$CEND"
  end_msg="%$((       $end_offset      ))s $DELIM"
  printf "$branch_l_text$behind_text$ahead_text$branch_r_text$end_msg\n"
}

Reset()
{
  WereAnyDivergences=0
  WereAnyCompared=0
  LocalW=0
  BehindW=0
  AheadW=0
  RemoteW=0
  BranchLeftTexts=()  ; BranchLeftColors=()  ;
  BehindTexts=()      ; BehindColors=()      ;
  TrackingTexts=()    ; TrackingColors=()    ;
  AheadTexts=()       ; AheadColors=()       ;
  BranchRightTexts=() ; BranchRightColors=() ;
}


## main entry ##

Init $*
FetchRemotes
GenerateReports
